@page "/import-data"
@using FollowTheMoney.Services
@using FollowTheMoney.Models
@using Microsoft.AspNetCore.Components.Forms
@inject CsvImportService CsvImport
@rendermode InteractiveServer

<PageTitle>Import Data</PageTitle>

<div class="container mt-4">
    <h2>Import Data from CSV</h2>

    @if (step == 1)
    {
        <div class="card mt-3">
            <div class="card-header">
                <h4>Step 1: Select Entity Type</h4>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label class="form-label"><strong>What type of data are you importing?</strong></label>
                    <select class="form-select" @bind="selectedEntityType">
                        <option value="">-- Select Entity Type --</option>
                        @foreach (var model in modelTypes)
                        {
                            <option value="@model.AssemblyQualifiedName">@model.Name</option>
                        }
                    </select>
                </div>

                @if (!string.IsNullOrEmpty(selectedEntityType))
                {
                    <button class="btn btn-primary" @onclick="LoadEntityProperties">Next</button>
                }
            </div>
        </div>
    }

    @if (step == 2)
    {
        <div class="card mt-3">
            <div class="card-header">
                <h4>Step 2: Upload CSV File</h4>
            </div>
            <div class="card-body">
                <InputFile OnChange="HandleFileSelected" class="form-control" accept=".csv" />

                @if (isProcessing)
                {
                    <div class="mt-3">
                        <div class="spinner-border" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span class="ms-2">Reading CSV...</span>
                    </div>
                }

                <div class="mt-3">
                    <button class="btn btn-secondary" @onclick="ResetImport">Back</button>
                </div>
            </div>
        </div>
    }

    @if (step == 3 && csvHeaders != null && mappableProperties != null)
    {
        <div class="card mt-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h4>Step 3: Map CSV Columns to @selectedEntityDisplayName Fields</h4>
                <button class="btn btn-sm btn-outline-primary" @onclick="AutoMapColumns">Auto-Map</button>
            </div>
            <div class="card-body">
                <p class="text-muted">Match your CSV columns to the database fields. Required fields are marked with *</p>

                <div class="mb-3">
                    <input type="text" class="form-control" placeholder="Search fields..." @bind="searchFilter"
                           @bind:event="oninput" />
                </div>

                <div class="row g-3">
                    @foreach (var property in GetFilteredProperties())
                    {
                        <div class="col-md-6 col-lg-4">
                            <label class="form-label">
                                <strong>@property.DisplayName @(property.IsRequired ? "*" : "")</strong>
                                @if (!string.IsNullOrEmpty(property.Description))
                                {
                                    <br />
                                    <small class="text-muted">@property.Description</small>
                                }
                                <br />
                                <small class="badge bg-secondary">@GetTypeDisplayName(property.PropertyType)</small>
                            </label>
                            @{
                                var currentMapping = columnMapping.GetValueOrDefault(property.PropertyName) ?? "";
                            }
                            <select
                                class="form-select @(property.IsRequired && string.IsNullOrEmpty(currentMapping) ? "border-danger" : "")"
                                value="@currentMapping"
                                @onchange="@(e => columnMapping[property.PropertyName] = e.Value?.ToString() ?? "")">
                                <option value="">-- Skip this field --</option>
                                @foreach (var header in csvHeaders)
                                {
                                    <option value="@header">@header</option>
                                }
                            </select>
                        </div>
                    }
                </div>

                <div class="mt-4">
                    <button class="btn btn-secondary me-2" @onclick="() => step = 2">Back</button>
                    <button class="btn btn-primary" @onclick="ProcessImport" disabled="@isProcessing">
                        @if (isProcessing)
                        {
                            <span class="spinner-border spinner-border-sm me-2"></span>
                        }
                        Import Data
                    </button>
                </div>

                @if (GetMissingRequiredFields().Any())
                {
                    <div class="alert alert-warning mt-3">
                        <strong>Missing required fields:</strong>
                        @string.Join(", ", GetMissingRequiredFields())
                    </div>
                }
            </div>
        </div>
    }

    @if (!string.IsNullOrEmpty(message))
    {
        <div class="alert @(isError ? "alert-danger" : "alert-success") mt-3">
            @message

            @if (importErrors.Any())
            {
                <hr />
                <h6>Errors (@importErrors.Count):</h6>
                <div style="max-height: 300px; overflow-y: auto;">
                    <ul class="mb-0">
                        @foreach (var error in importErrors.Take(20))
                        {
                            <li><small>@error</small></li>
                        }
                        @if (importErrors.Count > 20)
                        {
                            <li><em>... and @(importErrors.Count - 20) more errors</em></li>
                        }
                    </ul>
                </div>
            }
        </div>
    }
</div>

@code {
    private int step = 1;
    private bool isProcessing = false;
    private string message = "";
    private bool isError = false;
    private List<string> importErrors = new();

    private List<Type> modelTypes = new();
    private string selectedEntityType = "";
    private string selectedEntityDisplayName = "";
    private IBrowserFile? selectedFile;
    private byte[]? csvFileContent;
    private string[]? csvHeaders;
    private Dictionary<string, string> columnMapping = new();
    private List<PropertyMappingInfo>? mappableProperties;
    private string searchFilter = "";

    protected override void OnInitialized()
    {
        modelTypes = GetAllModelTypes();
    }

    private List<Type> GetAllModelTypes()
    {
        return typeof(FollowTheMoneyDbContext).Assembly
            .GetTypes()
            //.Where(t => t.IsClass && !t.IsAbstract)
            //.Where(t => t.Namespace == "FollowTheMoney.Models")
            .Where(t => t.GetProperty("Id") != null)
            .OrderBy(t => t.Name)
            .ToList();
    }

    private void LoadEntityProperties()
    {
        if (string.IsNullOrEmpty(selectedEntityType))
            return;

        var type = Type.GetType(selectedEntityType);
        if (type == null)
        {
            message = "Could not resolve selected model type.";
            isError = true;
            return;
        }

        selectedEntityDisplayName = type.Name;

        try
        {
            var method = typeof(CsvImportService)
                .GetMethod(nameof(CsvImportService.GetMappableProperties), 1, Type.EmptyTypes);

            if (method == null)
            {
                message = "GetMappableProperties<T>() not found on CsvImportService.";
                isError = true;
                return;
            }

            var generic = method.MakeGenericMethod(type);
            mappableProperties = (List<PropertyMappingInfo>)generic.Invoke(CsvImport, null)!;

            columnMapping = mappableProperties
                .ToDictionary(p => p.PropertyName, p => "");

            step = 2;
        }
        catch (Exception ex)
        {
            message = $"Error loading entity properties: {ex.Message}";
            isError = true;
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        isProcessing = true;
        message = "";
        isError = false;

        try
        {
            selectedFile = e.File;

            if (selectedFile.ContentType != "text/csv" && !selectedFile.Name.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
            {
                message = "Please select a CSV file";
                isError = true;
                return;
            }

            using var stream = selectedFile.OpenReadStream(maxAllowedSize: 50 * 1024 * 1024);
            using var memoryStream = new MemoryStream();
            await stream.CopyToAsync(memoryStream);
            csvFileContent = memoryStream.ToArray();

            memoryStream.Position = 0;
            using var reader = new StreamReader(memoryStream);
            var headerLine = await reader.ReadLineAsync();

            if (headerLine != null)
            {
                csvHeaders = headerLine.Split(',')
                    .Select(h => h.Trim().Trim('"'))
                    .ToArray();

                AutoMapColumns();
                step = 3;
            }
            else
            {
                message = "CSV file appears to be empty.";
                isError = true;
            }
        }
        catch (Exception ex)
        {
            message = $"Error reading CSV: {ex.Message}";
            isError = true;
        }
        finally
        {
            isProcessing = false;
        }
    }

    private void AutoMapColumns()
    {
        if (csvHeaders == null || mappableProperties == null) return;

        foreach (var property in mappableProperties)
        {
            var exactMatch = csvHeaders.FirstOrDefault(h =>
                h.Equals(property.PropertyName, StringComparison.OrdinalIgnoreCase));

            if (exactMatch != null)
            {
                columnMapping[property.PropertyName] = exactMatch;
                continue;
            }

            var displayMatch = csvHeaders.FirstOrDefault(h =>
                h.Equals(property.DisplayName, StringComparison.OrdinalIgnoreCase));

            if (displayMatch != null)
            {
                columnMapping[property.PropertyName] = displayMatch;
                continue;
            }

            var lowerProperty = property.PropertyName.ToLower();
            var partialMatch = csvHeaders.FirstOrDefault(h =>
                h.ToLower().Contains(lowerProperty) ||
                lowerProperty.Contains(h.ToLower()));

            if (partialMatch != null)
            {
                columnMapping[property.PropertyName] = partialMatch;
            }
        }

        StateHasChanged();
    }

    private async Task ProcessImport()
    {
        if (csvFileContent == null || mappableProperties == null || string.IsNullOrEmpty(selectedEntityType))
            return;

        var missingRequired = GetMissingRequiredFields();
        if (missingRequired.Any())
        {
            message = $"Please map all required fields: {string.Join(", ", missingRequired)}";
            isError = true;
            return;
        }

        isProcessing = true;
        message = "";
        isError = false;
        importErrors.Clear();

        try
        {
            using var stream = new MemoryStream(csvFileContent);

            var requiredFields = mappableProperties
                .Where(p => p.IsRequired)
                .ToDictionary(p => p.PropertyName, p => p.DisplayName);

            var type = Type.GetType(selectedEntityType);
            if (type == null)
            {
                message = "Could not resolve selected model type.";
                isError = true;
                return;
            }

            var method = typeof(CsvImportService)
                .GetMethod(nameof(CsvImportService.ImportFromCsv), 1,
                    new[] { typeof(Stream), typeof(Dictionary<string, string>), typeof(Dictionary<string, string>) });

            if (method == null)
            {
                message = "ImportFromCsv<T>() not found on CsvImportService.";
                isError = true;
                return;
            }

            var generic = method.MakeGenericMethod(type);
            var task = (Task)generic.Invoke(CsvImport, new object[] { stream, columnMapping, requiredFields })!;
            await task;

            var resultProperty = task.GetType().GetProperty("Result");
            var result = ((int successCount, List<string> errors))resultProperty!.GetValue(task)!;

            var success = result.successCount;
            var errors = result.errors;
            importErrors = errors;

            if (success > 0)
            {
                message = $"Successfully imported {success} {selectedEntityDisplayName} record(s)!";
                if (errors.Any())
                {
                    message += $" ({errors.Count} rows had errors and were skipped)";
                }
                isError = false;

                await Task.Delay(2000);
                ResetImport();
            }
            else
            {
                message = "No records were imported. Check the errors below.";
                isError = true;
            }
        }
        catch (Exception ex)
        {
            message = $"Error importing CSV: {ex.Message}";
            isError = true;
        }
        finally
        {
            isProcessing = false;
        }
    }

    private List<string> GetMissingRequiredFields()
    {
        if (mappableProperties == null) return new();

        return mappableProperties
            .Where(p => p.IsRequired && string.IsNullOrEmpty(columnMapping.GetValueOrDefault(p.PropertyName)))
            .Select(p => p.DisplayName)
            .ToList();
    }

    private List<PropertyMappingInfo> GetFilteredProperties()
    {
        if (mappableProperties == null) return new();

        if (string.IsNullOrWhiteSpace(searchFilter))
            return mappableProperties;

        return mappableProperties
            .Where(p => p.DisplayName.Contains(searchFilter, StringComparison.OrdinalIgnoreCase) ||
                        p.PropertyName.Contains(searchFilter, StringComparison.OrdinalIgnoreCase))
            .ToList();
    }

    private string GetTypeDisplayName(Type type)
    {
        var underlyingType = Nullable.GetUnderlyingType(type) ?? type;

        if (underlyingType == typeof(string)) return "Text";
        if (underlyingType == typeof(int)) return "Number";
        if (underlyingType == typeof(decimal)) return "Decimal";
        if (underlyingType == typeof(DateTime)) return "Date";
        if (underlyingType == typeof(Guid)) return "ID";
        if (underlyingType == typeof(bool)) return "Yes/No";
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>))
            return "List";

        return underlyingType.Name;
    }

    private void ResetImport()
    {
        step = 1;
        selectedEntityType = "";
        selectedEntityDisplayName = "";
        selectedFile = null;
        csvFileContent = null;
        csvHeaders = null;
        columnMapping.Clear();
        mappableProperties = null;
        message = "";
        isError = false;
        importErrors.Clear();
        searchFilter = "";
    }
}